#include <iostream>		//директива include подключает библиотеку iostream
#include <ctime>		//Подключаем библиотеку с помощью которой можно вызывать функцию time
#include <string>		//Библиотека позволяющая работать с классом string (строки)
#define PI 3.14			//Определили константу PI
#include <vector>		//Добавляем библиотеку vector, динамический контейнер
#include <list>			//Добавляем библиотеку list, двусвязный список, динамический контейнер

using namespace std;	//пространство имен, для сокращения кода




					//ООП

//Что такое ООП:

/*
- Инкапсуляция - механизм языка C++, ограничивающий доступ к составляющим объект компонентам 
				(методам и атрибутам), делает их защищенными или приватными, то есть доступными 
				только внутри объекта.

- Наследование - это способ организовывать иерархии классов. При этом класс-наследник приобретает поля и 
				функции базового класса, модифицируя их область видимости.

- Полиморфизм - это свойство программного кода изменять свое поведение в зависимости от ситуации, 
				возникающей при выполнении программы. 

*/

//Классы:

/*
- Класс это пользовательский тип данных т.е это тип данных, которую я создал сам
- Класс создается перед функцией main();

	class Human				//создали класс (class название_класса)
	{
	public:					//Определяем модицикатор доступа (обязательно)
							//Между фигурных скобок тело (параметры) класса

	int age;
	string name;


	};						//После завершения класса, необходимо ставить ';'

	int main()----------------------------------------------------------------------

	Human firstMan;			//Создаем объект класса (Переменную нашего типа данных)

							//Присваиваем значения свойств age int, объекта firstMan из класса Human;
	firstMan.age = 24;
	firstMan.name = "Innokentiy YouNona Pridiskishkiii";

	cout << firstMan.age << endl;
	cout << firstMan.name << endl;
====================================================================================
МЕТОДЫ И ФУНКЦИИ КЛАССА:

- Методы и функции класса представляют из себя одно и тоже;
- Функция класса определяется внутри тела класса;
- Функция внутри класса может взаимодействовать с переменными внутри того же класса

	class Human
	{
	public:

	int age;
	char name;
	int weight;

	void Print()				//Определяем функцию в классе
	{
		cout << name << endl;		
	}
	
	
	};

	int main()
	{

	firstMan.Print();		//Вызов функции для конкретного объекта в классе 

	}
*/

//Модификаторы доступа:

/*
- Мы можем использовать 3 вида модификаторов доступа в ООП. 
- private, public, protected

class Point
{
public:				- полный доступ к полям класса, через его бъект (т.е через точку)
	int x;
	int y;

private:			- без доступа через объект
	int z;

protected:			- Доступно для наследования другим классом
};

- В данном случае переменные x и y, будут иметь модификатор доступа public, а z будет private


*/

//Геттеры и сеттеры класса. Get, Set. Инкапсуляция:

/*
- По принципу инкапсуляции, оставлять данные класса публичными, запрещено. Т.е модификатор доступа public:
- Взаимодействовать с полями класса принято через геттеры и сеттеры
- Геттеры (Get) отвечают за получение инофрмации. 
  Сеттеры (Set) отвечают за установку, например присвоить значение переменной
- Геттеры и сеттеры являются методами (функциями) класса и должны быть в Public методе
	
	class Point
	{
	private:
		int x;
		int y;

	public:

		int GetX()			//Геттер должен возвращать значение, поэтому он не может быть void
		{
			return x;
		}

		void SetX(int valueX)		//Так как Сеттер принимает данные, он может быть void, но обязательно должен принимать аргумент
		{
			x = valueX;				//Присваиваем значение которое принимаем переменной в классе;
		}
	};


*/




						//STL

//VECTOR:

/*
- Вектор это тот же динамический массив, только с более широким функционалом;
- Вектор необходимо подключать через директиву #include
	#include <vector>

- Вектор создается в теле программы, и имеет такой вид: vector <тип_данных> название
	vector <int> myVector;

- Так как вектор является классом, он имеет множество методов, и их можно вызвать с помощью точки
	myVector.push_back(2);		//Добавляем в конец вектора элемент со значением 2

- Обращение к элементам вектора осуществляется так же как и с обычным массивом []
- Количество элементов в векторе хранит метод .size()
	for (int i = 0;i < myVector.size(); i++)
	{
		cout << myVector[i] << endl;
	}

- Изменить размер вектора можно с помощью метода .resize() 
- Так же к элементам вектора можно обратиться с помощью метода at()
- Разница между at() и [], в том что at() проверяет границы вектора, и не может обращаться к другой области памяти
- Но он является медленнее []
	myVector.at(2) = 4;		//обращаемся к элементу под индексом 2 и присваиваем ей значение 4

- Метод .clear() убирает все элементы в векторе
- Метод .pop_back удаляет последний элемент
- Метод .capacity() проверяет заразервированное место в векторе
- Метод .reserve() меняет количество capacity()
- Метод .shrink_to_fit() удаляет зарезервированное место и оставляет только количество size()
- Метод .insert() добавляет элемент в любое место под любой индекс
- Метод .erase() удаляет элемент под любым индексом

*/

//Итераторы Вектора

/*
- У каждого контейнера есть свой собственный итератор с которым он может взаимодействовать
- Создание итератора: vector <тип_данных_вектора>::iterator название_итератора
	vector <int>::iterator it;

- Итератор должен быть того же типа данных, что и вектор
- Чтобы использовать итератор, нужно связать его с вектором:
	it = myVector.begin();		//присваиваем итератору метод begin() нашего вектора

- Так как итератор является указателем, при его выводе нужно писать оператор разыменования:
	cout << *it << endl;

- Чтобы присвоить значение элемента через итератор, необходимо этот итератор разыменовать:
	*it = 1000		//Теперь значение первого элемента в векторе равна 1000
	
- Чтобы получить доступ к другим элементам используется арифметика указателей:
	it++;		//Сдвинули итератор на одну ячейку вправо
	it+=3		//Сдвинули итератор на 3 ячейки вправо
	it--;		//Сдвинули итератор на одну ячейку влево

- Итераторы в цикле создаются в самом цикле, а в условии остановки цикла используется метод .end(), 
	он указывает на место после последнего элемента в векторе т.е на пустоту
	
	for (vector <int>::iterator i = myVector.begin(); i != myVector.end(); i++)
	{
		cout << *i << endl;		//Используем разыменование, чтобы вывести данные на которые указывает итератор		
	}

- Чтобы изменить или получить данные на которые указывает итератор, необходимо использовать *
- А чтобы изменить значение самого итератора, обращаемся к нему без оператора разыменования т.е *

- Для того, чтобы сделать итератор константным, достаточно написать const_ перед iterator:
	vector <int>::const_iterator it;

- Еще один способ изменить значение итератора, это функция advance (итератор, на_сколько_сдвинуть):
	advance (it, 3);		//Сдвинули итератор на 3 ячейки вправо

- С помощью метода .insert(место_куда_будет_помещено_значение, число) можно добавлять новый элемент в векторе:
	myVector.insert(it, 3);		//добавили элемент со значением 3, на позицию которую указывает итератор

- Метод erase() удаляет элемент на который указывает итератор:
	myVector.erase(it);
*/

//LIST:

/*
- List - является двусвязным списком (динамическая структура данных). Он практически как Вектор, но с некоторыми особенностями
- Особенностью list явялется удаление и добавления элементов в любом месте
- Индексация с помощью квадратных скобок [], в List'е не положено
- Итерация Листа происходит только последовательно (т.е в порядке возрастания или убывания)
- Для того, чтобы работать с Листом, необходимо подключить библиотеку через директиву include: 
	#include <list>

- Синтаксис создания Листа: list<тип_данных> название
	list <int> myList;
	myList.push_back(5);		//Добавили в конец Листа элемент со значением 5;
	myList.push_front(10);		//Добавили в начало Листа элемент со значением 10;

- Синтаксис создания итератора: list<тип_данных>::iterator название;
	list <int>::iterator it = myList.begin();//Присвоили итератору метод начала Листа, таким образом итератор будет начинаться с начала;

- Для вывода или присвоения значения элемента на который указывает итератор необходимо использовать оператор разыменования *
	cout<< *it << endl;		//вывели на консоль значение элемента на который указывает итератор

- При создании итератора, можно использовать ключевое слово auto:
- (при этом необходимо, чтобы итератор был инициализирован в той же строчке в которой был создан)
	auto it = myList.begin();		//вместо list <int>::iterator it;

- метод .sort() посзволяет отсортировать элементы Листа по возрастанию
- методы .pop_back() и .pop_front позволяют удалять элементы в конце и начале
- метод .unique() удаляет из Листа дубликаты элементов которые идут последовательно
- метод .reverse() меняет порядок Списка

- метод .advance(итератор, на_сколько_сдвинуть) позволяет менять значение итератора и сдвигать его куда угодно
- метод .remove(значение_эдемента_который_нужно_удалить) удаляет значение в Листе который указан в виде аргумента



*/






					//ФУНКЦИИ и КЛАССЫ:

class Human				//создали класс (class название_класса)
{
public:					//Определяем модицикатор доступа (обязательно)
	int age;
	string name;		//Определяем свойства класса
	int weight;

	void Print()		//Прописываем функцию внутри класса
	{
		cout << "Имя: " << name << "\nВес: " << weight << "\nВозраст: " << age << endl << endl;
	}


};

class Point
{
private:
	int x;
	int y;

public:

	int GetX()			//Геттер должен возвращать значение, поэтому он не может быть void
	{
		return x;
	}

	void SetX(int valueX)		//Так как Сеттер принимает данные, он может быть void, но обязательно должен принимать аргумент
	{
		x = valueX;				//Присваиваем значение которое принимаем переменной в классе;
	}

	void SetY(int valueY)		
	{
		y = valueY;	
	}

	void Print()
	{
		cout << "X = " << x << "\nY = " << y << endl << endl;
	}
};

class CoffeeGrinder 
{
private:
	bool CheckVoltage() {
		return true;
	}

public:
	void Start()
	{

		if (CheckVoltage()) {
			cout << "VZHHHHuuuh" << endl;
		}
		else {
			cout << "Beep Beep" << endl;
		}
	}
};

//Создаем шаблонную функцию, которая принимает как аргумент лист с разными типами данных
//И превращающий все в константу
template <typename T>
void PrintList(const list <T>& lst)
{
	for (auto i = lst.begin(); i != lst.end(); ++i)
	{
		cout << *i << " ";
	}
	cout << endl;
}



int main ()
{

	setlocale(LC_ALL, "Rus");

	

	//Инкапсуляция:

	/*
							//ФУНКЦИИ и КЛАССЫ:
class CoffeeGrinder
{
private:
	bool CheckVoltage() {
		return true;
	}

public:
	void Start()
	{

		if (CheckVoltage()) {
			cout << "VZHHHHuuuh" << endl;
		}
		else {
			cout << "Beep Beep" << endl;
		}
	}
};

int main ()
{
	heehee.Start();
}

	*/

									//Библиотека стандартных шаблонов STL

	//VECTOR:

	/*
	vector <int> myVector = {10, 12, 12, 13};
	myVector.reserve(22);
	myVector.push_back(71);
	myVector.push_back(61);
	myVector.push_back(8);
	myVector.push_back(99);

	cout << "Количество элементов в векторе: " << myVector.size() << endl;
	cout << "apacity(): " << myVector.capacity() << endl;


	for (int i = 0; i < myVector.size(); i++)
	{
		cout << myVector[i] << endl;
	}
	*/

	//Итераторы Вектора:

	/*
	vector <int> myVector{ 10,33,42,22,11,11,11,11,11,22 };
	
	for (vector <int>::iterator i = myVector.begin(); i != myVector.end(); i++)
	{
		cout << *i << endl;
	}
	
	vector <int>::iterator it = myVector.begin();

	myVector.insert(it, 999);		//Меняем значение первого элемента т.к it = начало вектора (end())

	cout << "insert" << endl;


	for (vector <int>::iterator i = myVector.begin(); i != myVector.end(); i++)
	{
		cout << *i << endl;
	}


	cout << "\nerase()" << endl;

	vector<int>::iterator itErase = myVector.begin();

	myVector.erase(itErase);

	for (vector <int>::iterator i = myVector.begin(); i != myVector.end(); i++)
	{
		cout << *i << endl;
	}


	*/

	//LIST:

	/*
				//ФУНКЦИИ:

	//Создаем шаблонную функцию, которая принимает как аргумент лист с разными типами данных
	//И превращающий все в константу
	template <typename T>
	void PrintList(const list <T>& lst)
	{
		for (auto i = lst.begin(); i != lst.end(); ++i)
		{
			cout << *i << " ";
		}
		cout << endl;
	}



	int main ()
	{
	list <int> myList = {10,19,22,15};
	myList.push_back(5);
	myList.push_front(151);

	auto it = myList.begin();	//Создали итератор и присвоили ему начало нашего Листа (первый элемент);
								//вместо list <int>::iterator it, можно использовать auto;

	//Создаем цикл и в нем создаем итератор:
	for (auto i = myList.begin(); i != myList.end(); i++)
	{
		cout << *i << " ";
	}

	cout << endl;

	myList.sort();

	PrintList(myList);

	}
		
	*/

	list <int> myList = {10,19,22,15};
	myList.push_back(5);
	myList.push_front(151);

	auto it = myList.begin();	//Создали итератор и присвоили ему начало нашего Листа (первый элемент);
								//вместо list <int>::iterator it, можно использовать auto;

	//Создаем цикл и в нем создаем итератор:
	for (auto i = myList.begin(); i != myList.end(); i++)
	{
		cout << *i << " ";
	}

	cout << endl;

	myList.sort();

	PrintList(myList);





	system("pause");	//Функция для того, чтобы консоль сразу не закрывалась вне Visual Studio
	return 0;			//По  стандарту: Функция main() должна быть int и возвращать 0
}

