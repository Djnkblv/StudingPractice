#include <iostream>		//директива include подключает библиотеку iostream
#include <ctime>		//Подключаем библиотеку с помощью которой можно вызывать функцию time
#include <string>		//Библиотека позволяющая работать с классом string (строки)
#define PI 3.14			//Определили константу PI

using namespace std;	//пространство имен, для сокращения кода


//Строки. Строковые массивы:

/*
 - Тип данных char может хранить только одно значение, (один символ);

	char symbol = 'q'

- Но, если объявить переменную как массив, char может принимать множество символов;
- строка является массивом из символов char;

	char string[] = "abcdef";	//Символ обозначается одинарными кавычками '', а строка двойными "" ;

- последний элемент строкового массива, должен хранить в себе значение \0 (Нулл терминатор), что означает конец строки;

	char string [] = {'H','E','L','L','O',\0};

- Функция strlen показывает сколько символов в строке;

	cout << strlen(string) << endl;		//Вывод количества символов в переменной string;
 ===========================================================================================
 Строки и указатели:

	const char* string = "Hello!";

 - Со строками можно обращаться так же как и с динамическим массивом, если объявить указатель, то можно не обозначать
 строку как массив;

 - Функция strlen(), передает количество символов в строке:
	
	cout << strlen(str) << endl;
=========================================================================================
Конкатенация (обьединение) строк:

- Тип данных string, позволяет создавать переменные со значением строки;
- Для того, чтобы использовать тип данных string, необходимо подключить библиотеку <string>;
- Обьединение 2-х строк происходит путем их суммирования:
	string str1 = "Hello ";
	string str2 = "World!";
	string result;

	result = str1+ " " + str2;	//мы можем даже добавить пробел в переменную с типом данных string;
	cout << result << endl;

*/

//Преобразование типов в стиле С:

/*
- Для преобразования типа данных переменной в другой тип данных, перед названием переменной в скобках пишем новый тип данных;

	double a = 33.3;
	cout << (int)a << endl;		//из double преобразовали в int;

	a = (char)a;	//Преобразовали переменную а из int в char;

*/

//Указатели на функцию:

/*
- Синтаксис: тип функции(*имя указателя)(Спецификация параметров);

- Уазатель на функцию с одним типом данных, не будет указывать на функцию с другим типом данных;

	void(*fooPointer)();

	fooPointer = Foo1;		//Присваиваем функцию к указателю;

	fooPointer();			//Обращаемся к указателю, который выполняет функцию на которую указывает;

*/

//Директива #define. Макрос функция:

/*

- define переводится как определить;
- с помощью такой директивы, можно создавать макро-определения (макросы);

Например:	#define PI 3.14		//Определили константу PI, которая может в дальнейшем использоваться в программе;

- Отличие такого определения от обычной константы в том, что директива препроцессора определяет константу до компиляции;
==========================================================================================================

- макрос определяется с помощью директивы #define;
	
	#define MACROS(x,y)((x)*(y))	//Определили макрос который умножает параметры x и y;





*/

//Условная компиляция: 

/*
- Условные компиляции нужны для того, чтобы закомментировать большие участки кода;

- #ifdef и #endef #else;

	#ifdef DEBUG							//Если константа DEBUG определена директивой #define
		cout<<"Дебаг определен"<<endl;		//То выводим текст
	#else									//а если нет
		cout<<"Дебаг не опрделен"<<endl;	//то выводим вот этот текст
	#endif									//Конец ifdef'а

- Из кода понятно, что условная компиляция зависит от константы, которая определяется с помощью директивы #define;
- так же есть разновидность #ifndef, она работает так же, только инвертированно;
	
	#ifndef DEBUG							//Если DEBUG НЕ определен
		cout<<"Дебаг не определен"<<endl;	//То выводим этот текст
	#endif									//конец #ifndef'а 

- #if, #elif. Работает так же, только с конкретным условием:

	#if DEBUG < 4							//Если константа DEBUG меньше 4-х
		cout<<"DEBUG < 4"<<endl;			//То выводим данный текст
	#elif DEBUG == 5						//Если DEBUG равно 5 (Аналогично с else if)
		cout<<"DEBUG == 5"<<endl;			//То выводим данный текст
	#endif									//Конец #if'а

- Из кода понятно, что необходимо при определении константы DEBUG дать ей значение, например #define DEBUG 5


*/

//Тернарный услоный оператор:

/*
- Унарный оператор взаимодействует с одной переменной:
	a++;
	a+3;
- Бинарный оператор взаимодейстует с двумя переменными:
	a + b;
	b + d;
- тернарный опреатор повторяет if else, и выглядит так: "?:";
	(a < 10) ? cout << "a < 10" << endl : cout << "a >= 10" << endl;
	(условие) ? действие1 : действие2;	//если условие верное то действие1 если нет, то действие2
- ? (if), : (else);
	
- Логика else if:
	a < 10 ? cout << "a < 10" << endl : (a > 10) cout << "a >= 10" << endl : cout << "a == 10";
	(условие1) ? действие1 : (условие2) действие2 : действие3;

*/

//Параметры функции main (argc, argv):

/*
void main (int argc char* argv[])

- argc (arguments_coul) - говорит нам о том, сколько различный данных мы передали. Например: название программы и адрес сайта;
- argv (arguments_soul) - содержит строки и является массивом
- онинужны для того, чтобы программа принимала какой-то параметр, и выводила результат;
- если в консоли написать путь до exe-файла и указать параметры, то программа выведет результат
Например: Ввод: StudingPractice.exe Parameter1 Parameter3
		  Вывод: StudingPractice.exe
				 Parameter1
				 Parameter3

- argc не может быть меньше 1-го, т.е не может не передаваться;
*/

//int main или void main:

/*
- По стандарту функция main всегда должна возвращать int т.е после успешного завершения возвращать 0;
	int main();
	{

	return 0;
	}

*/

					//ООП

//Что такое ООП:

/*
- Инкапсуляция - механизм языка C++, ограничивающий доступ к составляющим объект компонентам 
				(методам и атрибутам), делает их защищенными или приватными, то есть доступными 
				только внутри объекта.

- Наследование - это способ организовывать иерархии классов. При этом класс-наследник приобретает поля и 
				функции базового класса, модифицируя их область видимости.

- Полиморфизм - это свойство программного кода изменять свое поведение в зависимости от ситуации, 
				возникающей при выполнении программы. 

*/

//Классы:

/*
- Класс это пользовательский тип данных т.е это тип данных, которую я создал сам
- Класс создается перед функцией main();

	class Human				//создали класс (class название_класса)
	{
	public:					//Определяем модицикатор доступа (обязательно)
							//Между фигурных скобок тело (параметры) класса

	int age;
	string name;


	};						//После завершения класса, необходимо ставить ';'

	int main()----------------------------------------------------------------------

	Human firstMan;			//Создаем объект класса (Переменную нашего типа данных)

							//Присваиваем значения свойств age int, объекта firstMan из класса Human;
	firstMan.age = 24;
	firstMan.name = "Innokentiy YouNona Pridiskishkiii";

	cout << firstMan.age << endl;
	cout << firstMan.name << endl;
====================================================================================
МЕТОДЫ И ФУНКЦИИ КЛАССА:

- Методы и функции класса представляют из себя одно и тоже;
- Функция класса определяется внутри тела класса;
- Функция внутри класса может взаимодействовать с переменными внутри того же класса

	class Human
	{
	public:

	int age;
	char name;
	int weight;

	void Print()				//Определяем функцию в классе
	{
		cout << name << endl;		
	}
	
	
	};

	int main()
	{

	firstMan.Print();		//Вызов функции для конкретного объекта в классе 

	}
*/

//Модификаторы доступа:

/*
- Мы можем использовать 3 вида модификаторов доступа в ООП. 
- private, public, protected

class Point
{
public:				- полный доступ к полям класса, через его бъект (т.е через точку)
	int x;
	int y;

private:			- без доступа через объект
	int z;

protected:			- Доступно для наследования другим классом
};

- В данном случае переменные x и y, будут иметь модификатор доступа public, а z будет private


*/

//Геттеры и сеттеры класса. Get, Set. Инкапсуляция:

/*
- По принципу инкапсуляции, оставлять данные класса публичными, запрещено. Т.е модификатор доступа public:
- Взаимодействовать с полями класса принято через геттеры и сеттеры
- Геттеры (Get) отвечают за получение инофрмации. 
  Сеттеры (Set) отвечают за установку, например присвоить значение переменной
- Геттеры и сеттеры являются методами (функциями) класса и должны быть в Public методе
	
	class Point
	{
	private:
		int x;
		int y;

	public:

		int GetX()			//Геттер должен возвращать значение, поэтому он не может быть void
		{
			return x;
		}

		void SetX(int valueX)		//Так как Сеттер принимает данные, он может быть void, но обязательно должен принимать аргумент
		{
			x = valueX;				//Присваиваем значение которое принимаем переменной в классе;
		}
	};


*/

					//ФУНКЦИИ и КЛАССЫ:

class Human				//создали класс (class название_класса)
{
public:					//Определяем модицикатор доступа (обязательно)
	int age;
	string name;		//Определяем свойства класса
	int weight;

	void Print()		//Прописываем функцию внутри класса
	{
		cout << "Имя: " << name << "\nВес: " << weight << "\nВозраст: " << age << endl << endl;
	}


};

class Point
{
private:
	int x;
	int y;

public:

	int GetX()			//Геттер должен возвращать значение, поэтому он не может быть void
	{
		return x;
	}

	void SetX(int valueX)		//Так как Сеттер принимает данные, он может быть void, но обязательно должен принимать аргумент
	{
		x = valueX;				//Присваиваем значение которое принимаем переменной в классе;
	}

	void SetY(int valueY)		
	{
		y = valueY;	
	}

	void Print()
	{
		cout << "X = " << x << "\nY = " << y << endl << endl;
	}
};

int main ()
{

	setlocale(LC_ALL, "Rus");

	//Строки и указатели. ДЗ:

	/*

 					//ФУНКЦИИ:
int StrLength(const char* str)
{
	int counter = 0;
	//Пока значение строки с итераторатором counter не равен \0 (концу строки), прибавляем ему 1;
	while (str[counter]!='\0')
	{
		counter++;
	}

	return counter;
}


int main()
{
	//Написать свою реализацию функции strlen (Считает количество символов в строке);

	const char* str = "Hello!";

	cout << StrLength(str) << endl;
	*/

	//Конкатенация строк:
	
	/*
	string str1 = "Мартин";
	string str2 = "Игоревич";
	string str3 = "Дугин";
	string result;

	result = "Фамилия " + str3 + "\tИмя " + str1 + "\tОтчество " + str2;
	
	
	cout << result << endl;
	*/

	//Указатели на функции:

	/*
						//ФУНКЦИИ:


string GetDataFromBD()		//Приставка Get, говорит о том, что функция что-то получает и возвращает результат;
{
	return "Data From BD";
}

string GetDataFromWebServer()
{
	return "Data From Web Server";
}


void ShowInfo(string(*foo)())		//Функция, которая локально создает указатель на функцию с типом данных string;
{
	cout << foo() << endl;			//Обращаемся к указателю и выводим значение функции на который он указывает;
}


int main()

{
	ShowInfo(GetDataFromBD);	 //Вызываем функцию, которая выводит данные другой функции, с помощью указателя;
}
	*/

	
	//Классы:

	/*
						//КЛАССЫ:
	class Point
{
public:
	int x;
	int y;
	int z;
};
	

	int main ()
{
	
	Point a;

	a.x = 10;
	a.y = 22;
	a.z = 3;
}
	
	*/

	//Методы класса. Сеттеры и геттеры:

	/*
						//ФУНКЦИИ и КЛАССЫ:
class Point
{
private:
	int x;
	int y;

public:

	int GetX()			//Геттер должен возвращать значение, поэтому он не может быть void
	{
		return x;
	}

	void SetX(int valueX)		//Так как Сеттер принимает данные, он может быть void, но обязательно должен принимать аргумент
	{
		x = valueX;				//Присваиваем значение которое принимаем переменной в классе;
	}

	void SetY(int valueY)		
	{
		y = valueY;	
	}

	void Print()
	{
		cout << "X = " << x << "\nY = " << y << endl << endl;
	}
};

int main ()
{
	

	Point a;

	a.Print();
	a.SetX(60);
	a.SetY(52);
	a.Print();
}
	*/

	Human firstMan;			//Создаем объект класса (Переменную нашего типа данных)

							//Присваиваем значения свойств age int, объекта firstMan из класса Human;
	

	Point a;

	a.Print();
	a.SetX(60);
	a.SetY(52);
	a.Print();
	





	system("pause");	//Функция для того, чтобы консоль сразу не закрывалась вне Visual Studio
	return 0;			//По  стандарту: Функция main() должна быть int и возвращать 0
}
